<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>netstandard2.0;net10.0</TargetFrameworks>
    <RootNamespace>SchemaTools</RootNamespace>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <!-- net10.0 doubles as a CLI executable for dotnet exec invocation.
       Full Framework MSBuild (msbuild.exe / Visual Studio) shells out to this
       for DacFx-dependent post-build tasks, avoiding SSDT assembly collisions.
       UseAppHost=false: no native host needed; invoked via dotnet exec. -->
  <PropertyGroup Condition="'$(TargetFramework)' == 'net10.0'">
    <OutputType>Exe</OutputType>
    <UseAppHost>false</UseAppHost>
  </PropertyGroup>

  <!-- DacFx-dependent code is net10.0 only.
       netstandard2.0 (Full Framework MSBuild) cannot load DacFx in-process because
       SSDT's SqlBuild has already loaded DacFx with the same assembly identity
       (Version=170.0.0.0, PublicKeyToken=89845dcd8080cc91) into the AppDomain.
       Excluding these files removes the DacFx assembly reference entirely. -->
  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <Compile Remove="Extraction\**\*.cs" />
    <Compile Remove="Tasks\SchemaMetadataExtractor.cs" />
    <Compile Remove="Program.cs" />
  </ItemGroup>

  <ItemGroup>
    <InternalsVisibleTo Include="SchemaTools.Tests" />
  </ItemGroup>

  <PropertyGroup>
    <!-- Package metadata -->
    <PackageId>SchemaTools</PackageId>
    <Product>SchemaTools</Product>
    <Description>MSBuild tasks for generating metadata, triggers, and documentation from SQL Server database schemas. Supports temporal tables, soft delete patterns, and polymorphic relationships.</Description>
    <PackageTags>sql-server;database;schema;msbuild;ssdt;temporal-tables;soft-delete;metadata;code-generation</PackageTags>
    <PackageProjectUrl>https://github.com/arashi01/schema-tools</PackageProjectUrl>
    <RepositoryType>git</RepositoryType>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <PackageReadmeFile>README.md</PackageReadmeFile>

    <!-- NuGet package settings -->
    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
    <IncludeSymbols>true</IncludeSymbols>
    <SymbolPackageFormat>snupkg</SymbolPackageFormat>
    <PublishRepositoryUrl>true</PublishRepositoryUrl>
    <EmbedUntrackedSources>true</EmbedUntrackedSources>

    <!-- GenerateDocumentationFile is required by EnforceCodeStyleInBuild for
         IDE0005 (unused usings). CS1591 (missing XML docs) is suppressed because
         this project has no public API surface: all public types are either
         MSBuild tasks (instantiated by reflection) or internal models exposed
         to tests via InternalsVisibleTo. -->
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);CS1591</NoWarn>
  </PropertyGroup>

  <!-- ===========================================================================
       MSBuild Task Packaging

       MSBuild tasks must be packaged differently from regular libraries:
       - DLLs go in tasks/ (not lib/) to avoid being treated as compile references
       - All runtime dependencies must be bundled inside the package
       - MSBuild assemblies are excluded (provided by the host at runtime)
       - A deps.json helps MSBuild resolve the correct dependency versions

       See: https://learn.microsoft.com/visualstudio/msbuild/tutorial-custom-task-code-generation
       =========================================================================== -->
  <PropertyGroup>
    <!-- Pack task DLLs to tasks/{tfm}/ instead of lib/{tfm}/ -->
    <BuildOutputTargetFolder>tasks</BuildOutputTargetFolder>

    <!-- Copy NuGet dependency assemblies to output directory for bundling -->
    <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>

    <!-- Generate deps.json for MSBuild dependency resolution -->
    <GenerateDependencyFile>true</GenerateDependencyFile>

    <!-- Suppress NuGet warnings:
         NU5100 - assemblies in tasks/ folder (intentional for MSBuild tasks)
         NU5128 - no lib/ or ref/ assemblies (we are a task package, not a library) -->
    <NoWarn>$(NoWarn);NU5100;NU5128</NoWarn>

    <!-- Do not expose bundled dependencies as NuGet package dependencies -->
    <SuppressDependenciesWhenPacking>true</SuppressDependenciesWhenPacking>

    <!-- Hook into packaging to bundle runtime dependencies alongside the task DLL -->
    <TargetsForTfmSpecificBuildOutput>
      $(TargetsForTfmSpecificBuildOutput);CopyProjectReferencesToPackage
    </TargetsForTfmSpecificBuildOutput>
  </PropertyGroup>

  <ItemGroup>
    <!-- MSBuild dependencies: provided by the MSBuild host at runtime.
         PrivateAssets="all"    - do not expose as package dependencies
         ExcludeAssets="Runtime" - do not copy to output (MSBuild provides these) -->
    <PackageReference Include="Microsoft.Build.Framework" Version="18.3.3"
                      PrivateAssets="all" ExcludeAssets="Runtime" />
    <PackageReference Include="Microsoft.Build.Utilities.Core" Version="18.3.3"
                      PrivateAssets="all" ExcludeAssets="Runtime" />

    <!-- SQL Server ScriptDom for parsing T-SQL (bundled in package) -->
    <PackageReference Include="Microsoft.SqlServer.TransactSql.ScriptDom" Version="170.168.0"
                      PrivateAssets="all" />

    <!-- Compiler attribute polyfills for netstandard2.0 (IsExternalInit, required, etc.)
         Source generator: emits internal polyfill types at compile time, zero runtime cost -->
    <PackageReference Include="PolySharp" Version="1.15.0" PrivateAssets="all" />

    <!-- Source link for debugging -->
    <PackageReference Include="Microsoft.SourceLink.GitHub" Version="10.0.103" PrivateAssets="all" />
  </ItemGroup>

  <!-- DacFx: net10.0 only. The netstandard2.0 build has no DacFx-dependent code
       (excluded via Compile Remove above), so no reference is needed. -->
  <ItemGroup Condition="'$(TargetFramework)' == 'net10.0'">
    <PackageReference Include="Microsoft.SqlServer.DacFx" Version="170.3.93"
                      PrivateAssets="all" />
  </ItemGroup>

  <!-- System.Text.Json is in-box for net10.0 but must be referenced for netstandard2.0 -->
  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="System.Text.Json" Version="10.0.3" PrivateAssets="all" />
  </ItemGroup>

  <ItemGroup>
    <!-- Include MSBuild targets in package -->
    <None Include="build\**\*.targets" Pack="true" PackagePath="build\" />
    <None Include="build\**\*.props" Pack="true" PackagePath="build\" />

    <!-- Include README -->
    <None Include="..\README.md" Pack="true" PackagePath="\" />
  </ItemGroup>

  <!-- Bundle all runtime dependency assemblies into the NuGet package
       alongside the task DLL in tasks/{tfm}/ -->
  <Target Name="CopyProjectReferencesToPackage" DependsOnTargets="ResolveReferences">
    <ItemGroup>
      <BuildOutputInPackage Include="@(ReferenceCopyLocalPaths)"
                            TargetPath="%(ReferenceCopyLocalPaths.DestinationSubPath)" />
    </ItemGroup>
  </Target>

  <!-- Include the generated deps.json in the package output -->
  <Target Name="AddBuildDependencyFileToBuiltProjectOutputGroupOutput"
          BeforeTargets="BuiltProjectOutputGroup"
          Condition="'$(GenerateDependencyFile)' == 'true'">
    <ItemGroup>
      <BuiltProjectOutputGroupOutput Include="$(ProjectDepsFilePath)"
                                     TargetPath="$(ProjectDepsFileName)"
                                     FinalOutputPath="$(ProjectDepsFilePath)" />
    </ItemGroup>
  </Target>

  <!-- Include runtimeconfig.json for net10.0 so dotnet exec can resolve the target framework.
       Only net10.0 is an Exe; netstandard2.0 has no runtimeconfig. -->
  <Target Name="AddRuntimeConfigToBuiltProjectOutputGroupOutput"
          BeforeTargets="BuiltProjectOutputGroup"
          Condition="'$(TargetFramework)' == 'net10.0'">
    <ItemGroup>
      <BuiltProjectOutputGroupOutput Include="$(ProjectRuntimeConfigFilePath)"
                                     TargetPath="$(ProjectRuntimeConfigFileName)"
                                     FinalOutputPath="$(ProjectRuntimeConfigFilePath)" />
    </ItemGroup>
  </Target>

</Project>
